# 虚拟内存管理

因为使用了平坦模式，所以分页机制被 `绕过去` 了，因此分页成了内存管理的
核心。

Linux 采用的方案是把内核映射到线性地址空间3G以上, 而应用程序占据线性地址空间 0-3G 的位置。
我们的内核采取和 Linux 内核一样的映射, 把物理地址 0 从虚拟地址 0xC0000000(3G) 处开始往上映
射, 因为我们只管理最多 512MB 的内存, 所以 3G-4G 之间能完全的映射全部的物理地址。采
取这个映射后, 物理地址和内核虚拟地址满足以下关系:

> 物理地址 + 0xc0000000 = 内核虚拟地址

我们先引入 VMA(Virtual Memory Address) 和 LMA(Load Memory Address) 这两
个概念。其中 VMA 是链接器生成可执行文件时的偏移计算地址, 而 LMA 是区段所载入内存的
实际地址。通常情况下的 VMA 是等于 LMA 的。

## ld 指定段的起始位置

将某一段的代码放在固定位置，其它段按照链接器来链接安排。

由于入口函数的位置发生了改变，所以以前的很多代码都需要修改，这里的逻辑参考教程。

## 虚拟内存

虚拟内存的实现其实更加简单一点，对于内存地址的转换由 MMU 来实现，所以核心的逻辑是实现虚拟地址到
物理地址的转化，并且处理缺页中断。

缺页中断：访问虚拟地址时，发现没有对应的物理地址，因此产生缺页错误。

缺页中断号为 14，可以在中断处理器中去处理缺页错误。

## 总结

涉及到虚拟地址的开启，但之前的很多代码必须在放在固定的某些内存中，不能重定位，
所以使用了 ld 链接器的扩展功能，因此也修改了很多代码。

剩下的就是虚拟地址到物理地址转换，缺页中断的实现。
