# 物理内存管理

内存管理是操作系统非常非常重要的一个模块，在前面有分段式的内存管理，本小节开始，
会进入操作系统的分页内存管理。

在 `保护模式` 下，注意一定是在保护模式下，CPU 在开启分页前后，MMU 组建处理地址的流程
分别如下：

* 没有开启分页：逻辑地址 -> 段机制处理 -> 线性地址 = 物理地址
* 开启分页：逻辑地址 -> 段机制处理 -> 线性地址 -> 页机制处理 -> 物理地址

因为 `段机制` 这里采用了平坦模式，所以段地址就等于线性地址。

分页是内存管理中的核心机制。如果没有分页，那么操作系统管理内存会十分麻烦，有了分页后，
MMU 组建将内存划分为定长的物理页，同时程序执行的时候将线性地址划分为逻辑页，在这种机制
下，会有一组数据结构专门来管理二者的映射关系。

也就是说，虽然线性地址（由逻辑地址转换而来）是连续的，但是物理地址可以是不连续，甚至线性地址
可以映射到磁盘，于是就有了 `swap` 技术。

虚拟内存实质上就是把物理内存中暂时用不到的内容暂时换出到外存里, 空出内存放置现阶段
需要的数据。

所以分页机制也引发了一个问题，那就是如何管理页，这个页映射数据也得放到内存中的某一个地方。

当映射数据安排好了，开启分页模式， CPU 就会按照分页模式的规则去解释线性地址了。

**补充一点**：对于一个 32 位的计算机来说，它有 32 根地址总线，其中一些区域映射到 BIOS 和
外设，所以并没有和内存一一对应，所以分段机制可以通过段选择子来将地址空间段氏转换后映射到
所有的内存中，使 CPU 可以访问所有的内存，这也是段机制存在的核心关键。

## 分页

既然是分页，那么每个页究竟有多大了？如果分页太小，会有极多的页，那么管理结构会
很麻烦，如果分页太大。那么又会浪费内存，以页为单位来分配内存，有些页的内存
压根没有用完。

但是每个进程都有自己的分页映射，如果是 100 个进程，那么就会有大量的内存浪费在映射
上面，所以就提出了 `分级页表` 的策略。

这个分级页面是这样的，将地址，比如 32 位地址，分为了 3 段来寻址，分别是低 12 位，
中间 10 位和高 10 位。

高 10 位表示当前地址项在页目录中的偏移，最终偏移处指向对应的页表，中间 10 位是当前
地址在页中的偏移，按照这个偏移就来计算出物理页，最低 12 位是地址在页中的偏移。

## 内存管理

1. 如何获取可用物理内存的大小和地址?

获取物理内存的方法一般有 BIOS 调用和直接探测等方法, 但
是 GRUB 的 Mutliboot 协议提供了更简单的方法。还记得那个 multiboot_t 结构体吗? GRUB
已经获取了物理内存的分布并且把它们放置在了这个结构体里的以下两个成员里。

通过链接脚本来提供物理内存地址的开始和结束位置，将内核的这一块内存排除在外。

2. 采用什么样的数据结构来描述物理内存?

页表，将页的开始，结束定义位一个 mmap_entry_t 结构体

3. 申请和释放物理内存的算法如何实现?

使用栈。

注意：内存管理的实质，内存的分配和释放其实都是由操作系统来在逻辑上实现的，即一块内存，操作系统分配给你了，
那么你就拥有这块内存的访问和写入权限，如果访问其它进程的内存操作系统就会禁止且报错。

因此内存中的数据不会在这块内存回收的时候而清除，操作只是将这块内存标记为空闲且可分配，当这块内存再分配的时候
由这块内存的拥有者来负责操作这块内存。

## 总结

本小节，主要是内存分页的建立和管理。对于可用内存，GRUB 已经将数据写入到了 multiboot_t 中，然后通过链接
脚本提供的变量排除掉内核内存，其它内存就是可分配的。

内存的分配和回收其实没有那么神秘，本质上还是由内核控制，给某个进程内存的使用权，禁止使用没有被分配的内存。
内存回收后，只是在页表上改变了标志位，这块内存的数据其实并为改变，新的使用者会覆盖原来的数据。


